
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>proto: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/Alieksieiev0/auth-service/api/proto/auth_service.pb.go (34.8%)</option>
				
				<option value="file1">github.com/Alieksieiev0/auth-service/api/proto/auth_service_grpc.pb.go (58.8%)</option>
				
				<option value="file2">github.com/Alieksieiev0/auth-service/api/proto/user_service.pb.go (7.7%)</option>
				
				<option value="file3">github.com/Alieksieiev0/auth-service/api/proto/user_service_grpc.pb.go (0.0%)</option>
				
				<option value="file4">github.com/Alieksieiev0/auth-service/cmd/auth-service/main.go (0.0%)</option>
				
				<option value="file5">github.com/Alieksieiev0/auth-service/internal/app/app.go (0.0%)</option>
				
				<option value="file6">github.com/Alieksieiev0/auth-service/internal/services/auth.go (80.8%)</option>
				
				<option value="file7">github.com/Alieksieiev0/auth-service/internal/services/token.go (78.6%)</option>
				
				<option value="file8">github.com/Alieksieiev0/auth-service/internal/transport/grpc/client.go (20.0%)</option>
				
				<option value="file9">github.com/Alieksieiev0/auth-service/internal/transport/grpc/server.go (76.9%)</option>
				
				<option value="file10">github.com/Alieksieiev0/auth-service/internal/transport/rest/handler.go (72.0%)</option>
				
				<option value="file11">github.com/Alieksieiev0/auth-service/internal/transport/rest/server.go (100.0%)</option>
				
				<option value="file12">github.com/Alieksieiev0/auth-service/tests/data/data.go (93.8%)</option>
				
				<option value="file13">github.com/Alieksieiev0/auth-service/tests/mocks/token_service.go (100.0%)</option>
				
				<option value="file14">github.com/Alieksieiev0/auth-service/tests/mocks/user_proto.go (42.9%)</option>
				
				<option value="file15">github.com/Alieksieiev0/auth-service/tests/utils/utils.go (93.3%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
//         protoc-gen-go v1.28.1
//         protoc        v4.25.3
// source: api/proto/auth_service.proto

package proto

import (
        protoreflect "google.golang.org/protobuf/reflect/protoreflect"
        protoimpl "google.golang.org/protobuf/runtime/protoimpl"
        timestamppb "google.golang.org/protobuf/types/known/timestamppb"
        reflect "reflect"
        sync "sync"
)

const (
        // Verify that this generated code is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
        // Verify that runtime/protoimpl is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type Token struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Value string `protobuf:"bytes,1,opt,name=value,proto3" json:"value,omitempty"`
}

func (x *Token) Reset() <span class="cov8" title="1">{
        *x = Token{}
        if protoimpl.UnsafeEnabled </span><span class="cov8" title="1">{
                mi := &amp;file_api_proto_auth_service_proto_msgTypes[0]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *Token) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*Token) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *Token) ProtoReflect() protoreflect.Message <span class="cov8" title="1">{
        mi := &amp;file_api_proto_auth_service_proto_msgTypes[0]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov8" title="1">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov8" title="1">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov8" title="1">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use Token.ProtoReflect.Descriptor instead.
func (*Token) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_api_proto_auth_service_proto_rawDescGZIP(), []int{0}
}</span>

func (x *Token) GetValue() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Value
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type UserClaims struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        UserId    string                 `protobuf:"bytes,1,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
        Username  string                 `protobuf:"bytes,2,opt,name=username,proto3" json:"username,omitempty"`
        Email     string                 `protobuf:"bytes,3,opt,name=email,proto3" json:"email,omitempty"`
        Algorithm string                 `protobuf:"bytes,4,opt,name=algorithm,proto3" json:"algorithm,omitempty"`
        Issuer    string                 `protobuf:"bytes,5,opt,name=issuer,proto3" json:"issuer,omitempty"`
        Subject   string                 `protobuf:"bytes,6,opt,name=subject,proto3" json:"subject,omitempty"`
        Audience  []string               `protobuf:"bytes,7,rep,name=audience,proto3" json:"audience,omitempty"`
        ExpiresAt *timestamppb.Timestamp `protobuf:"bytes,8,opt,name=expires_at,json=expiresAt,proto3" json:"expires_at,omitempty"`
        NotBefore *timestamppb.Timestamp `protobuf:"bytes,9,opt,name=not_before,json=notBefore,proto3" json:"not_before,omitempty"`
        IssuedAt  *timestamppb.Timestamp `protobuf:"bytes,10,opt,name=issued_at,json=issuedAt,proto3" json:"issued_at,omitempty"`
        Id        string                 `protobuf:"bytes,11,opt,name=id,proto3" json:"id,omitempty"`
}

func (x *UserClaims) Reset() <span class="cov8" title="1">{
        *x = UserClaims{}
        if protoimpl.UnsafeEnabled </span><span class="cov8" title="1">{
                mi := &amp;file_api_proto_auth_service_proto_msgTypes[1]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *UserClaims) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*UserClaims) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *UserClaims) ProtoReflect() protoreflect.Message <span class="cov8" title="1">{
        mi := &amp;file_api_proto_auth_service_proto_msgTypes[1]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov8" title="1">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov8" title="1">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov8" title="1">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use UserClaims.ProtoReflect.Descriptor instead.
func (*UserClaims) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_api_proto_auth_service_proto_rawDescGZIP(), []int{1}
}</span>

func (x *UserClaims) GetUserId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.UserId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *UserClaims) GetUsername() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Username
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *UserClaims) GetEmail() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Email
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *UserClaims) GetAlgorithm() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Algorithm
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *UserClaims) GetIssuer() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Issuer
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *UserClaims) GetSubject() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Subject
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *UserClaims) GetAudience() []string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Audience
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *UserClaims) GetExpiresAt() *timestamppb.Timestamp <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ExpiresAt
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *UserClaims) GetNotBefore() *timestamppb.Timestamp <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.NotBefore
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *UserClaims) GetIssuedAt() *timestamppb.Timestamp <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.IssuedAt
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *UserClaims) GetId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Id
        }</span>
        <span class="cov0" title="0">return ""</span>
}

var File_api_proto_auth_service_proto protoreflect.FileDescriptor

var file_api_proto_auth_service_proto_rawDesc = []byte{
        0x0a, 0x1c, 0x61, 0x70, 0x69, 0x2f, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2f, 0x61, 0x75, 0x74, 0x68,
        0x5f, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x1f,
        0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2f, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2f,
        0x74, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x22,
        0x1d, 0x0a, 0x05, 0x54, 0x6f, 0x6b, 0x65, 0x6e, 0x12, 0x14, 0x0a, 0x05, 0x76, 0x61, 0x6c, 0x75,
        0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x22, 0x82,
        0x03, 0x0a, 0x0a, 0x55, 0x73, 0x65, 0x72, 0x43, 0x6c, 0x61, 0x69, 0x6d, 0x73, 0x12, 0x17, 0x0a,
        0x07, 0x75, 0x73, 0x65, 0x72, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x06,
        0x75, 0x73, 0x65, 0x72, 0x49, 0x64, 0x12, 0x1a, 0x0a, 0x08, 0x75, 0x73, 0x65, 0x72, 0x6e, 0x61,
        0x6d, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x75, 0x73, 0x65, 0x72, 0x6e, 0x61,
        0x6d, 0x65, 0x12, 0x14, 0x0a, 0x05, 0x65, 0x6d, 0x61, 0x69, 0x6c, 0x18, 0x03, 0x20, 0x01, 0x28,
        0x09, 0x52, 0x05, 0x65, 0x6d, 0x61, 0x69, 0x6c, 0x12, 0x1c, 0x0a, 0x09, 0x61, 0x6c, 0x67, 0x6f,
        0x72, 0x69, 0x74, 0x68, 0x6d, 0x18, 0x04, 0x20, 0x01, 0x28, 0x09, 0x52, 0x09, 0x61, 0x6c, 0x67,
        0x6f, 0x72, 0x69, 0x74, 0x68, 0x6d, 0x12, 0x16, 0x0a, 0x06, 0x69, 0x73, 0x73, 0x75, 0x65, 0x72,
        0x18, 0x05, 0x20, 0x01, 0x28, 0x09, 0x52, 0x06, 0x69, 0x73, 0x73, 0x75, 0x65, 0x72, 0x12, 0x18,
        0x0a, 0x07, 0x73, 0x75, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x18, 0x06, 0x20, 0x01, 0x28, 0x09, 0x52,
        0x07, 0x73, 0x75, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x12, 0x1a, 0x0a, 0x08, 0x61, 0x75, 0x64, 0x69,
        0x65, 0x6e, 0x63, 0x65, 0x18, 0x07, 0x20, 0x03, 0x28, 0x09, 0x52, 0x08, 0x61, 0x75, 0x64, 0x69,
        0x65, 0x6e, 0x63, 0x65, 0x12, 0x39, 0x0a, 0x0a, 0x65, 0x78, 0x70, 0x69, 0x72, 0x65, 0x73, 0x5f,
        0x61, 0x74, 0x18, 0x08, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c,
        0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x54, 0x69, 0x6d, 0x65, 0x73,
        0x74, 0x61, 0x6d, 0x70, 0x52, 0x09, 0x65, 0x78, 0x70, 0x69, 0x72, 0x65, 0x73, 0x41, 0x74, 0x12,
        0x39, 0x0a, 0x0a, 0x6e, 0x6f, 0x74, 0x5f, 0x62, 0x65, 0x66, 0x6f, 0x72, 0x65, 0x18, 0x09, 0x20,
        0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f,
        0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x54, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x52,
        0x09, 0x6e, 0x6f, 0x74, 0x42, 0x65, 0x66, 0x6f, 0x72, 0x65, 0x12, 0x37, 0x0a, 0x09, 0x69, 0x73,
        0x73, 0x75, 0x65, 0x64, 0x5f, 0x61, 0x74, 0x18, 0x0a, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e,
        0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e,
        0x54, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x52, 0x08, 0x69, 0x73, 0x73, 0x75, 0x65,
        0x64, 0x41, 0x74, 0x12, 0x0e, 0x0a, 0x02, 0x69, 0x64, 0x18, 0x0b, 0x20, 0x01, 0x28, 0x09, 0x52,
        0x02, 0x69, 0x64, 0x32, 0x30, 0x0a, 0x0b, 0x41, 0x75, 0x74, 0x68, 0x53, 0x65, 0x72, 0x76, 0x69,
        0x63, 0x65, 0x12, 0x21, 0x0a, 0x0a, 0x52, 0x65, 0x61, 0x64, 0x43, 0x6c, 0x61, 0x69, 0x6d, 0x73,
        0x12, 0x06, 0x2e, 0x54, 0x6f, 0x6b, 0x65, 0x6e, 0x1a, 0x0b, 0x2e, 0x55, 0x73, 0x65, 0x72, 0x43,
        0x6c, 0x61, 0x69, 0x6d, 0x73, 0x42, 0x30, 0x5a, 0x2e, 0x67, 0x69, 0x74, 0x68, 0x75, 0x62, 0x2e,
        0x63, 0x6f, 0x6d, 0x2f, 0x41, 0x6c, 0x69, 0x65, 0x6b, 0x73, 0x69, 0x65, 0x69, 0x65, 0x76, 0x30,
        0x2f, 0x66, 0x65, 0x65, 0x64, 0x2d, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x2f, 0x61, 0x70,
        0x69, 0x2f, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33,
}

var (
        file_api_proto_auth_service_proto_rawDescOnce sync.Once
        file_api_proto_auth_service_proto_rawDescData = file_api_proto_auth_service_proto_rawDesc
)

func file_api_proto_auth_service_proto_rawDescGZIP() []byte <span class="cov0" title="0">{
        file_api_proto_auth_service_proto_rawDescOnce.Do(func() </span><span class="cov0" title="0">{
                file_api_proto_auth_service_proto_rawDescData = protoimpl.X.CompressGZIP(file_api_proto_auth_service_proto_rawDescData)
        }</span>)
        <span class="cov0" title="0">return file_api_proto_auth_service_proto_rawDescData</span>
}

var file_api_proto_auth_service_proto_msgTypes = make([]protoimpl.MessageInfo, 2)
var file_api_proto_auth_service_proto_goTypes = []interface{}{
        (*Token)(nil),                 // 0: Token
        (*UserClaims)(nil),            // 1: UserClaims
        (*timestamppb.Timestamp)(nil), // 2: google.protobuf.Timestamp
}
var file_api_proto_auth_service_proto_depIdxs = []int32{
        2, // 0: UserClaims.expires_at:type_name -&gt; google.protobuf.Timestamp
        2, // 1: UserClaims.not_before:type_name -&gt; google.protobuf.Timestamp
        2, // 2: UserClaims.issued_at:type_name -&gt; google.protobuf.Timestamp
        0, // 3: AuthService.ReadClaims:input_type -&gt; Token
        1, // 4: AuthService.ReadClaims:output_type -&gt; UserClaims
        4, // [4:5] is the sub-list for method output_type
        3, // [3:4] is the sub-list for method input_type
        3, // [3:3] is the sub-list for extension type_name
        3, // [3:3] is the sub-list for extension extendee
        0, // [0:3] is the sub-list for field type_name
}

func init() <span class="cov8" title="1">{ file_api_proto_auth_service_proto_init() }</span>
func file_api_proto_auth_service_proto_init() <span class="cov8" title="1">{
        if File_api_proto_auth_service_proto != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">if !protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                file_api_proto_auth_service_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*Token); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_api_proto_auth_service_proto_msgTypes[1].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*UserClaims); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
        }
        <span class="cov8" title="1">type x struct{}
        out := protoimpl.TypeBuilder{
                File: protoimpl.DescBuilder{
                        GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
                        RawDescriptor: file_api_proto_auth_service_proto_rawDesc,
                        NumEnums:      0,
                        NumMessages:   2,
                        NumExtensions: 0,
                        NumServices:   1,
                },
                GoTypes:           file_api_proto_auth_service_proto_goTypes,
                DependencyIndexes: file_api_proto_auth_service_proto_depIdxs,
                MessageInfos:      file_api_proto_auth_service_proto_msgTypes,
        }.Build()
        File_api_proto_auth_service_proto = out.File
        file_api_proto_auth_service_proto_rawDesc = nil
        file_api_proto_auth_service_proto_goTypes = nil
        file_api_proto_auth_service_proto_depIdxs = nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             v4.25.3
// source: api/proto/auth_service.proto

package proto

import (
        context "context"
        grpc "google.golang.org/grpc"
        codes "google.golang.org/grpc/codes"
        status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// AuthServiceClient is the client API for AuthService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type AuthServiceClient interface {
        ReadClaims(ctx context.Context, in *Token, opts ...grpc.CallOption) (*UserClaims, error)
}

type authServiceClient struct {
        cc grpc.ClientConnInterface
}

func NewAuthServiceClient(cc grpc.ClientConnInterface) AuthServiceClient <span class="cov8" title="1">{
        return &amp;authServiceClient{cc}
}</span>

func (c *authServiceClient) ReadClaims(ctx context.Context, in *Token, opts ...grpc.CallOption) (*UserClaims, error) <span class="cov8" title="1">{
        out := new(UserClaims)
        err := c.cc.Invoke(ctx, "/AuthService/ReadClaims", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return out, nil</span>
}

// AuthServiceServer is the server API for AuthService service.
// All implementations must embed UnimplementedAuthServiceServer
// for forward compatibility
type AuthServiceServer interface {
        ReadClaims(context.Context, *Token) (*UserClaims, error)
        mustEmbedUnimplementedAuthServiceServer()
}

// UnimplementedAuthServiceServer must be embedded to have forward compatible implementations.
type UnimplementedAuthServiceServer struct {
}

func (UnimplementedAuthServiceServer) ReadClaims(context.Context, *Token) (*UserClaims, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method ReadClaims not implemented")
}</span>
func (UnimplementedAuthServiceServer) mustEmbedUnimplementedAuthServiceServer() {<span class="cov0" title="0">}</span>

// UnsafeAuthServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to AuthServiceServer will
// result in compilation errors.
type UnsafeAuthServiceServer interface {
        mustEmbedUnimplementedAuthServiceServer()
}

func RegisterAuthServiceServer(s grpc.ServiceRegistrar, srv AuthServiceServer) <span class="cov8" title="1">{
        s.RegisterService(&amp;AuthService_ServiceDesc, srv)
}</span>

func _AuthService_ReadClaims_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov8" title="1">{
        in := new(Token)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if interceptor == nil </span><span class="cov8" title="1">{
                return srv.(AuthServiceServer).ReadClaims(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/AuthService/ReadClaims",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(AuthServiceServer).ReadClaims(ctx, req.(*Token))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

// AuthService_ServiceDesc is the grpc.ServiceDesc for AuthService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var AuthService_ServiceDesc = grpc.ServiceDesc{
        ServiceName: "AuthService",
        HandlerType: (*AuthServiceServer)(nil),
        Methods: []grpc.MethodDesc{
                {
                        MethodName: "ReadClaims",
                        Handler:    _AuthService_ReadClaims_Handler,
                },
        },
        Streams:  []grpc.StreamDesc{},
        Metadata: "api/proto/auth_service.proto",
}
</pre>
		
		<pre class="file" id="file2" style="display: none">// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
//         protoc-gen-go v1.28.1
//         protoc        v4.25.3
// source: api/proto/user_service.proto

package proto

import (
        protoreflect "google.golang.org/protobuf/reflect/protoreflect"
        protoimpl "google.golang.org/protobuf/runtime/protoimpl"
        reflect "reflect"
        sync "sync"
)

const (
        // Verify that this generated code is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
        // Verify that runtime/protoimpl is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type UsernameRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Username string `protobuf:"bytes,1,opt,name=username,proto3" json:"username,omitempty"`
}

func (x *UsernameRequest) Reset() <span class="cov0" title="0">{
        *x = UsernameRequest{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_api_proto_user_service_proto_msgTypes[0]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *UsernameRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*UsernameRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *UsernameRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_api_proto_user_service_proto_msgTypes[0]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use UsernameRequest.ProtoReflect.Descriptor instead.
func (*UsernameRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_api_proto_user_service_proto_rawDescGZIP(), []int{0}
}</span>

func (x *UsernameRequest) GetUsername() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Username
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type UserResponse struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Id       string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
        Username string `protobuf:"bytes,2,opt,name=username,proto3" json:"username,omitempty"`
        Password string `protobuf:"bytes,3,opt,name=password,proto3" json:"password,omitempty"`
        Email    string `protobuf:"bytes,4,opt,name=email,proto3" json:"email,omitempty"`
}

func (x *UserResponse) Reset() <span class="cov0" title="0">{
        *x = UserResponse{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_api_proto_user_service_proto_msgTypes[1]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *UserResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*UserResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *UserResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_api_proto_user_service_proto_msgTypes[1]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use UserResponse.ProtoReflect.Descriptor instead.
func (*UserResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_api_proto_user_service_proto_rawDescGZIP(), []int{1}
}</span>

func (x *UserResponse) GetId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Id
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *UserResponse) GetUsername() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Username
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *UserResponse) GetPassword() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Password
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *UserResponse) GetEmail() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Email
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type UserRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Username string `protobuf:"bytes,1,opt,name=username,proto3" json:"username,omitempty"`
        Password string `protobuf:"bytes,2,opt,name=password,proto3" json:"password,omitempty"`
        Email    string `protobuf:"bytes,3,opt,name=email,proto3" json:"email,omitempty"`
}

func (x *UserRequest) Reset() <span class="cov0" title="0">{
        *x = UserRequest{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_api_proto_user_service_proto_msgTypes[2]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *UserRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*UserRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *UserRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_api_proto_user_service_proto_msgTypes[2]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use UserRequest.ProtoReflect.Descriptor instead.
func (*UserRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_api_proto_user_service_proto_rawDescGZIP(), []int{2}
}</span>

func (x *UserRequest) GetUsername() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Username
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *UserRequest) GetPassword() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Password
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *UserRequest) GetEmail() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Email
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type SaveResponse struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields
}

func (x *SaveResponse) Reset() <span class="cov0" title="0">{
        *x = SaveResponse{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_api_proto_user_service_proto_msgTypes[3]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *SaveResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*SaveResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *SaveResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_api_proto_user_service_proto_msgTypes[3]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use SaveResponse.ProtoReflect.Descriptor instead.
func (*SaveResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_api_proto_user_service_proto_rawDescGZIP(), []int{3}
}</span>

var File_api_proto_user_service_proto protoreflect.FileDescriptor

var file_api_proto_user_service_proto_rawDesc = []byte{
        0x0a, 0x1c, 0x61, 0x70, 0x69, 0x2f, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2f, 0x75, 0x73, 0x65, 0x72,
        0x5f, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x22, 0x2d,
        0x0a, 0x0f, 0x55, 0x73, 0x65, 0x72, 0x6e, 0x61, 0x6d, 0x65, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73,
        0x74, 0x12, 0x1a, 0x0a, 0x08, 0x75, 0x73, 0x65, 0x72, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x01, 0x20,
        0x01, 0x28, 0x09, 0x52, 0x08, 0x75, 0x73, 0x65, 0x72, 0x6e, 0x61, 0x6d, 0x65, 0x22, 0x6c, 0x0a,
        0x0c, 0x55, 0x73, 0x65, 0x72, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x0e, 0x0a,
        0x02, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x02, 0x69, 0x64, 0x12, 0x1a, 0x0a,
        0x08, 0x75, 0x73, 0x65, 0x72, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52,
        0x08, 0x75, 0x73, 0x65, 0x72, 0x6e, 0x61, 0x6d, 0x65, 0x12, 0x1a, 0x0a, 0x08, 0x70, 0x61, 0x73,
        0x73, 0x77, 0x6f, 0x72, 0x64, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x70, 0x61, 0x73,
        0x73, 0x77, 0x6f, 0x72, 0x64, 0x12, 0x14, 0x0a, 0x05, 0x65, 0x6d, 0x61, 0x69, 0x6c, 0x18, 0x04,
        0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x65, 0x6d, 0x61, 0x69, 0x6c, 0x22, 0x5b, 0x0a, 0x0b, 0x55,
        0x73, 0x65, 0x72, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x1a, 0x0a, 0x08, 0x75, 0x73,
        0x65, 0x72, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x75, 0x73,
        0x65, 0x72, 0x6e, 0x61, 0x6d, 0x65, 0x12, 0x1a, 0x0a, 0x08, 0x70, 0x61, 0x73, 0x73, 0x77, 0x6f,
        0x72, 0x64, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x70, 0x61, 0x73, 0x73, 0x77, 0x6f,
        0x72, 0x64, 0x12, 0x14, 0x0a, 0x05, 0x65, 0x6d, 0x61, 0x69, 0x6c, 0x18, 0x03, 0x20, 0x01, 0x28,
        0x09, 0x52, 0x05, 0x65, 0x6d, 0x61, 0x69, 0x6c, 0x22, 0x0e, 0x0a, 0x0c, 0x53, 0x61, 0x76, 0x65,
        0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x32, 0x68, 0x0a, 0x0b, 0x55, 0x73, 0x65, 0x72,
        0x53, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x12, 0x32, 0x0a, 0x0d, 0x47, 0x65, 0x74, 0x42, 0x79,
        0x55, 0x73, 0x65, 0x72, 0x6e, 0x61, 0x6d, 0x65, 0x12, 0x10, 0x2e, 0x55, 0x73, 0x65, 0x72, 0x6e,
        0x61, 0x6d, 0x65, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x0d, 0x2e, 0x55, 0x73, 0x65,
        0x72, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x00, 0x12, 0x25, 0x0a, 0x04, 0x53,
        0x61, 0x76, 0x65, 0x12, 0x0c, 0x2e, 0x55, 0x73, 0x65, 0x72, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73,
        0x74, 0x1a, 0x0d, 0x2e, 0x53, 0x61, 0x76, 0x65, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65,
        0x22, 0x00, 0x42, 0x30, 0x5a, 0x2e, 0x67, 0x69, 0x74, 0x68, 0x75, 0x62, 0x2e, 0x63, 0x6f, 0x6d,
        0x2f, 0x41, 0x6c, 0x69, 0x65, 0x6b, 0x73, 0x69, 0x65, 0x69, 0x65, 0x76, 0x30, 0x2f, 0x66, 0x65,
        0x65, 0x64, 0x2d, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x2f, 0x61, 0x70, 0x69, 0x2f, 0x70,
        0x72, 0x6f, 0x74, 0x6f, 0x62, 0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33,
}

var (
        file_api_proto_user_service_proto_rawDescOnce sync.Once
        file_api_proto_user_service_proto_rawDescData = file_api_proto_user_service_proto_rawDesc
)

func file_api_proto_user_service_proto_rawDescGZIP() []byte <span class="cov0" title="0">{
        file_api_proto_user_service_proto_rawDescOnce.Do(func() </span><span class="cov0" title="0">{
                file_api_proto_user_service_proto_rawDescData = protoimpl.X.CompressGZIP(file_api_proto_user_service_proto_rawDescData)
        }</span>)
        <span class="cov0" title="0">return file_api_proto_user_service_proto_rawDescData</span>
}

var file_api_proto_user_service_proto_msgTypes = make([]protoimpl.MessageInfo, 4)
var file_api_proto_user_service_proto_goTypes = []interface{}{
        (*UsernameRequest)(nil), // 0: UsernameRequest
        (*UserResponse)(nil),    // 1: UserResponse
        (*UserRequest)(nil),     // 2: UserRequest
        (*SaveResponse)(nil),    // 3: SaveResponse
}
var file_api_proto_user_service_proto_depIdxs = []int32{
        0, // 0: UserService.GetByUsername:input_type -&gt; UsernameRequest
        2, // 1: UserService.Save:input_type -&gt; UserRequest
        1, // 2: UserService.GetByUsername:output_type -&gt; UserResponse
        3, // 3: UserService.Save:output_type -&gt; SaveResponse
        2, // [2:4] is the sub-list for method output_type
        0, // [0:2] is the sub-list for method input_type
        0, // [0:0] is the sub-list for extension type_name
        0, // [0:0] is the sub-list for extension extendee
        0, // [0:0] is the sub-list for field type_name
}

func init() <span class="cov8" title="1">{ file_api_proto_user_service_proto_init() }</span>
func file_api_proto_user_service_proto_init() <span class="cov8" title="1">{
        if File_api_proto_user_service_proto != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">if !protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                file_api_proto_user_service_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*UsernameRequest); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_api_proto_user_service_proto_msgTypes[1].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*UserResponse); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_api_proto_user_service_proto_msgTypes[2].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*UserRequest); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_api_proto_user_service_proto_msgTypes[3].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*SaveResponse); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
        }
        <span class="cov8" title="1">type x struct{}
        out := protoimpl.TypeBuilder{
                File: protoimpl.DescBuilder{
                        GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
                        RawDescriptor: file_api_proto_user_service_proto_rawDesc,
                        NumEnums:      0,
                        NumMessages:   4,
                        NumExtensions: 0,
                        NumServices:   1,
                },
                GoTypes:           file_api_proto_user_service_proto_goTypes,
                DependencyIndexes: file_api_proto_user_service_proto_depIdxs,
                MessageInfos:      file_api_proto_user_service_proto_msgTypes,
        }.Build()
        File_api_proto_user_service_proto = out.File
        file_api_proto_user_service_proto_rawDesc = nil
        file_api_proto_user_service_proto_goTypes = nil
        file_api_proto_user_service_proto_depIdxs = nil</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             v4.25.3
// source: api/proto/user_service.proto

package proto

import (
        context "context"
        grpc "google.golang.org/grpc"
        codes "google.golang.org/grpc/codes"
        status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// UserServiceClient is the client API for UserService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type UserServiceClient interface {
        GetByUsername(ctx context.Context, in *UsernameRequest, opts ...grpc.CallOption) (*UserResponse, error)
        Save(ctx context.Context, in *UserRequest, opts ...grpc.CallOption) (*SaveResponse, error)
}

type userServiceClient struct {
        cc grpc.ClientConnInterface
}

func NewUserServiceClient(cc grpc.ClientConnInterface) UserServiceClient <span class="cov0" title="0">{
        return &amp;userServiceClient{cc}
}</span>

func (c *userServiceClient) GetByUsername(ctx context.Context, in *UsernameRequest, opts ...grpc.CallOption) (*UserResponse, error) <span class="cov0" title="0">{
        out := new(UserResponse)
        err := c.cc.Invoke(ctx, "/UserService/GetByUsername", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *userServiceClient) Save(ctx context.Context, in *UserRequest, opts ...grpc.CallOption) (*SaveResponse, error) <span class="cov0" title="0">{
        out := new(SaveResponse)
        err := c.cc.Invoke(ctx, "/UserService/Save", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

// UserServiceServer is the server API for UserService service.
// All implementations must embed UnimplementedUserServiceServer
// for forward compatibility
type UserServiceServer interface {
        GetByUsername(context.Context, *UsernameRequest) (*UserResponse, error)
        Save(context.Context, *UserRequest) (*SaveResponse, error)
        mustEmbedUnimplementedUserServiceServer()
}

// UnimplementedUserServiceServer must be embedded to have forward compatible implementations.
type UnimplementedUserServiceServer struct {
}

func (UnimplementedUserServiceServer) GetByUsername(context.Context, *UsernameRequest) (*UserResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method GetByUsername not implemented")
}</span>
func (UnimplementedUserServiceServer) Save(context.Context, *UserRequest) (*SaveResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method Save not implemented")
}</span>
func (UnimplementedUserServiceServer) mustEmbedUnimplementedUserServiceServer() {<span class="cov0" title="0">}</span>

// UnsafeUserServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to UserServiceServer will
// result in compilation errors.
type UnsafeUserServiceServer interface {
        mustEmbedUnimplementedUserServiceServer()
}

func RegisterUserServiceServer(s grpc.ServiceRegistrar, srv UserServiceServer) <span class="cov0" title="0">{
        s.RegisterService(&amp;UserService_ServiceDesc, srv)
}</span>

func _UserService_GetByUsername_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(UsernameRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(UserServiceServer).GetByUsername(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/UserService/GetByUsername",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(UserServiceServer).GetByUsername(ctx, req.(*UsernameRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _UserService_Save_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(UserRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(UserServiceServer).Save(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/UserService/Save",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(UserServiceServer).Save(ctx, req.(*UserRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

// UserService_ServiceDesc is the grpc.ServiceDesc for UserService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var UserService_ServiceDesc = grpc.ServiceDesc{
        ServiceName: "UserService",
        HandlerType: (*UserServiceServer)(nil),
        Methods: []grpc.MethodDesc{
                {
                        MethodName: "GetByUsername",
                        Handler:    _UserService_GetByUsername_Handler,
                },
                {
                        MethodName: "Save",
                        Handler:    _UserService_Save_Handler,
                },
        },
        Streams:  []grpc.StreamDesc{},
        Metadata: "api/proto/user_service.proto",
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package main

import (
        "github.com/Alieksieiev0/auth-service/internal/app"
)

func main() <span class="cov0" title="0">{
        app.Run()
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package app

import (
        "flag"
        "log"

        "github.com/Alieksieiev0/auth-service/internal/services"
        "github.com/Alieksieiev0/auth-service/internal/transport/grpc"
        "github.com/Alieksieiev0/auth-service/internal/transport/rest"
        "github.com/gofiber/fiber/v2"
        "golang.org/x/sync/errgroup"
)

func Run() <span class="cov0" title="0">{
        var (
                restServerAddr = flag.String("rest-server", ":3001", "listen address of rest server")
                grpcServerAddr = flag.String("grpc-server", ":4001", "listen address of grpc server")
                grpcClientAddr = flag.String(
                        "grpc-client",
                        "feed-service:4000",
                        "listen address of grpc client",
                )
                tokenService = services.NewTokenService()
                app          = fiber.New()
                g            = new(errgroup.Group)
        )

        client, err := grpc.NewGRPCUserServiceClient(*grpcClientAddr)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>

        <span class="cov0" title="0">authService := services.NewAuthService(client, tokenService)

        grpcServer := grpc.NewServer(*grpcServerAddr)
        g.Go(func() error </span><span class="cov0" title="0">{
                return grpcServer.Start(authService)
        }</span>)

        <span class="cov0" title="0">restServer := rest.NewServer(app, *restServerAddr)
        g.Go(func() error </span><span class="cov0" title="0">{
                return restServer.Start(authService)
        }</span>)

        <span class="cov0" title="0">if err := g.Wait(); err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package services

import (
        "context"
        "fmt"
        "time"

        "github.com/Alieksieiev0/auth-service/api/proto"
        "github.com/Alieksieiev0/auth-service/internal/types"
        "golang.org/x/crypto/bcrypt"
)

const exp time.Duration = time.Hour * 6

type AuthService interface {
        Register(ctx context.Context, user *types.User) error
        Login(ctx context.Context, user *types.User) (*types.UserToken, error)
        ReadClaims(ctx context.Context, token *types.Token) (*types.UserClaims, error)
}

type authService struct {
        client       proto.UserServiceClient
        tokenService TokenService
}

func NewAuthService(client proto.UserServiceClient, tokenService TokenService) AuthService <span class="cov8" title="1">{
        return &amp;authService{
                client:       client,
                tokenService: tokenService,
        }
}</span>

func (as *authService) Register(ctx context.Context, user *types.User) error <span class="cov8" title="1">{
        userRequest := &amp;proto.UserRequest{
                Username: user.Username,
                Email:    user.Email,
                Password: user.Password,
        }

        user.Password = ""
        _, err := as.client.Save(ctx, userRequest)
        return err
}</span>

func (as *authService) Login(ctx context.Context, user *types.User) (*types.UserToken, error) <span class="cov8" title="1">{
        username := &amp;proto.UsernameRequest{
                Username: user.Username,
        }

        resp, err := as.client.GetByUsername(ctx, username)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("user with such username does not exist")
        }</span>

        <span class="cov8" title="1">err = bcrypt.CompareHashAndPassword([]byte(resp.Password), []byte(user.Password))
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("provided password is incorrect")
        }</span>

        <span class="cov8" title="1">respUser := &amp;types.User{
                Id:       resp.Id,
                Username: resp.Username,
                Email:    resp.Email,
        }
        token, err := as.tokenService.Create(respUser, exp)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">userToken := &amp;types.UserToken{
                User: *respUser,
                Token: types.Token{
                        Value: token,
                },
        }

        return userToken, nil</span>
}

func (as *authService) ReadClaims(
        ctx context.Context,
        token *types.Token,
) (*types.UserClaims, error) <span class="cov8" title="1">{
        fmt.Println(as.tokenService)
        claims, err := as.tokenService.Read(token.Value)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">userClaims, ok := claims.(*types.UserClaims)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("you're Unauthorized due to claims parsing error")
        }</span>

        <span class="cov8" title="1">return userClaims, nil</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package services

import (
        "fmt"
        "time"

        "github.com/Alieksieiev0/auth-service/internal/types"
        "github.com/golang-jwt/jwt/v5"
)

const secret string = "d0881af56a560c2b86c7dd95ee5bd95a52864e2bd0b42396bba0b5ce974fe2cb6065eb3b03776997a6e9c2df22023e8c219b225b8df4390d10f4e9cc847010b9736a4dc09a51e2affad6afdd99efdee9bc407ba626f94db7ee8222b7a3e51dcf6ec5ffb4f7caa5ce90ea1a825022a0e75e24f475fb7f8f6a454f20c50b4db47064f6857a3db3850767a49af61aaab08e58e1ee6cf6756f05e228ebaa6ee64eeb7b3693dc7b6a47fd9ca06d25b8143d50aed0b543543ce1de500beb8f08e3eef8719eb59c8c7f69bcd887a363ae0bb978acec69ab092534d97bcafd4bbbdb73efb335860689f56c7b0c9be3ad57f6426dc4eb37bd5d7ee78f0c425dca53eaeae6"

type TokenService interface {
        Create(user *types.User, expiresAfter time.Duration) (string, error)
        Read(token string) (jwt.Claims, error)
}

func NewTokenService() TokenService <span class="cov8" title="1">{
        return &amp;JWTService{}
}</span>

type JWTService struct{}

func (js *JWTService) Create(user *types.User, expiresAfter time.Duration) (string, error) <span class="cov8" title="1">{
        token := jwt.NewWithClaims(jwt.SigningMethodHS256, types.UserClaims{
                UserId:    user.Id,
                Username:  user.Username,
                Email:     user.Email,
                Algorithm: jwt.SigningMethodHS256.Name,
                RegisteredClaims: jwt.RegisteredClaims{
                        ExpiresAt: jwt.NewNumericDate(time.Now().Add(expiresAfter)),
                },
        })

        signedToken, err := token.SignedString(
                []byte(
                        secret,
                ),
        )

        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">return signedToken, nil</span>

}

func (js *JWTService) Read(token string) (jwt.Claims, error) <span class="cov8" title="1">{
        parsedToken, err := jwt.ParseWithClaims(
                token,
                &amp;types.UserClaims{},
                func(token *jwt.Token) (interface{}, error) </span><span class="cov8" title="1">{
                        _, ok := token.Method.(*jwt.SigningMethodHMAC)
                        if !ok </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("you're Unauthorized due to error parsing the JWT")
                        }</span>
                        <span class="cov8" title="1">return []byte(secret), nil</span>
                },
                jwt.WithValidMethods([]string{jwt.SigningMethodHS256.Name}),
        )

        <span class="cov8" title="1">if err != nil || !parsedToken.Valid </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("you're Unauthorized due to invalid token")
        }</span>

        <span class="cov8" title="1">return parsedToken.Claims, nil</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package grpc

import (
        "github.com/Alieksieiev0/auth-service/api/proto"
        "google.golang.org/grpc"
        "google.golang.org/grpc/credentials/insecure"
)

func NewConnection(addr string) (*grpc.ClientConn, error) <span class="cov8" title="1">{
        return grpc.NewClient(addr, grpc.WithTransportCredentials(insecure.NewCredentials()))
}</span>

func NewGRPCUserServiceClient(addr string) (proto.UserServiceClient, error) <span class="cov0" title="0">{
        conn, err := NewConnection(addr)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return proto.NewUserServiceClient(conn), nil</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package grpc

import (
        "context"
        "fmt"
        "net"

        "github.com/Alieksieiev0/auth-service/api/proto"
        "github.com/Alieksieiev0/auth-service/internal/services"
        "github.com/Alieksieiev0/auth-service/internal/types"
        "google.golang.org/grpc"
        "google.golang.org/protobuf/types/known/timestamppb"
)

type GRPCServer struct {
        addr   string
        server *grpc.Server
}

func NewServer(addr string) *GRPCServer <span class="cov8" title="1">{
        return &amp;GRPCServer{
                addr: addr,
        }
}</span>

func (s *GRPCServer) Start(service services.AuthService) error <span class="cov8" title="1">{
        s.initializeServer(service)
        ln, err := net.Listen("tcp", s.addr)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return s.server.Serve(ln)</span>
}

func (s *GRPCServer) Stop() error <span class="cov8" title="1">{
        if s.server == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("server is not initialized to be stopped")
        }</span>

        <span class="cov8" title="1">s.server.Stop()
        return nil</span>
}

func (s *GRPCServer) initializeServer(service services.AuthService) <span class="cov8" title="1">{
        s.server = grpc.NewServer()
        grpcAuthServiceServer := NewGRPCAuthServiceServer(service)
        proto.RegisterAuthServiceServer(s.server, grpcAuthServiceServer)
}</span>

type GRPCAuthServiceServer struct {
        service services.AuthService
        proto.UnimplementedAuthServiceServer
}

func NewGRPCAuthServiceServer(service services.AuthService) *GRPCAuthServiceServer <span class="cov8" title="1">{
        return &amp;GRPCAuthServiceServer{
                service: service,
        }
}</span>

func (as *GRPCAuthServiceServer) ReadClaims(
        ctx context.Context,
        req *proto.Token,
) (*proto.UserClaims, error) <span class="cov8" title="1">{
        token := &amp;types.Token{
                Value: req.Value,
        }
        userClaims, err := as.service.ReadClaims(ctx, token)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">claims := &amp;proto.UserClaims{
                UserId:    userClaims.UserId,
                Username:  userClaims.Username,
                Email:     userClaims.Email,
                Algorithm: userClaims.Algorithm,
                Issuer:    userClaims.Issuer,
                Subject:   userClaims.Subject,
                Audience:  userClaims.Audience,
                Id:        userClaims.ID,
        }

        if userClaims.ExpiresAt != nil </span><span class="cov0" title="0">{
                claims.ExpiresAt = timestamppb.New(userClaims.ExpiresAt.Time)
        }</span>

        <span class="cov8" title="1">if userClaims.NotBefore != nil </span><span class="cov0" title="0">{
                claims.NotBefore = timestamppb.New(userClaims.NotBefore.Time)
        }</span>

        <span class="cov8" title="1">if userClaims.IssuedAt != nil </span><span class="cov0" title="0">{
                claims.IssuedAt = timestamppb.New(userClaims.IssuedAt.Time)
        }</span>

        <span class="cov8" title="1">return claims, err</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package rest

import (
        "fmt"
        "net/http"

        "github.com/Alieksieiev0/auth-service/internal/services"
        "github.com/Alieksieiev0/auth-service/internal/types"
        "github.com/gofiber/fiber/v2"
        "golang.org/x/crypto/bcrypt"
)

func login(service services.AuthService) fiber.Handler <span class="cov8" title="1">{
        return func(c *fiber.Ctx) error </span><span class="cov8" title="1">{
                user := &amp;types.User{}
                if err := c.BodyParser(user); err != nil </span><span class="cov0" title="0">{
                        return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{"error": err.Error()})
                }</span>

                <span class="cov8" title="1">if user.Username == "" &amp;&amp; user.Password == "" </span><span class="cov0" title="0">{
                        return c.Status(fiber.StatusBadRequest).
                                JSON(fiber.Map{"error": "insufficient user data"})
                }</span>

                <span class="cov8" title="1">userToken, err := service.Login(c.Context(), user)
                if err != nil </span><span class="cov0" title="0">{
                        return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{"error": err.Error()})
                }</span>

                <span class="cov8" title="1">return c.Status(http.StatusOK).JSON(userToken)</span>
        }
}

func register(service services.AuthService) fiber.Handler <span class="cov8" title="1">{
        return func(c *fiber.Ctx) error </span><span class="cov8" title="1">{
                user := &amp;types.User{}
                fmt.Println(string(c.Body()))
                if err := c.BodyParser(user); err != nil </span><span class="cov0" title="0">{
                        return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{"error": err.Error()})
                }</span>
                <span class="cov8" title="1">if user.Username == "" &amp;&amp; user.Email == "" &amp;&amp; user.Password == "" </span><span class="cov0" title="0">{
                        return c.Status(fiber.StatusBadRequest).
                                JSON(fiber.Map{"error": "insufficient user data"})
                }</span>

                <span class="cov8" title="1">hashedPassword, err := bcrypt.GenerateFromPassword(
                        []byte(user.Password),
                        bcrypt.DefaultCost,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return c.Status(fiber.StatusInternalServerError).
                                JSON(fiber.Map{"error": "couldnt process password"})
                }</span>

                <span class="cov8" title="1">user.Password = string(hashedPassword)
                if err := service.Register(c.Context(), user); err != nil </span><span class="cov0" title="0">{
                        return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{"error": err.Error()})
                }</span>

                <span class="cov8" title="1">c.Status(http.StatusCreated)
                return nil</span>
        }
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package rest

import (
        "github.com/Alieksieiev0/auth-service/internal/services"
        "github.com/gofiber/fiber/v2"
        "github.com/gofiber/fiber/v2/middleware/cors"
        "github.com/gofiber/fiber/v2/middleware/logger"
)

type RESTServer struct {
        app  *fiber.App
        addr string
}

func NewServer(app *fiber.App, addr string) *RESTServer <span class="cov8" title="1">{
        return &amp;RESTServer{
                app:  app,
                addr: addr,
        }
}</span>

func (us *RESTServer) Start(service services.AuthService) error <span class="cov8" title="1">{
        us.app.Use(logger.New(logger.Config{
                Format: "${time} | ${status} | ${latency} | ${method} | ${path} | ${error}\nResponse Body: ${resBody}\n",
        }))
        us.app.Use(cors.New())

        us.app.Post("/login", login(service))
        us.app.Post("/register", register(service))

        return us.app.Listen(us.addr)
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">package data

import (
        "github.com/Alieksieiev0/auth-service/api/proto"
        "github.com/Alieksieiev0/auth-service/internal/types"
        "golang.org/x/crypto/bcrypt"
)

func User() *types.User <span class="cov8" title="1">{
        return &amp;types.User{
                Username: "test",
                Email:    "test@test.com",
                Password: "something",
        }
}</span>

func UserPublic() *types.User <span class="cov8" title="1">{
        u := User()
        u.Id = "1234"
        u.Password = ""

        return u
}</span>

func UserClaims() *types.UserClaims <span class="cov8" title="1">{
        return &amp;types.UserClaims{
                UserId:    "1234",
                Username:  "test",
                Email:     "test@test.com",
                Algorithm: "some",
        }
}</span>

func ProtoUserRequest(user *types.User) *proto.UserRequest <span class="cov8" title="1">{
        return &amp;proto.UserRequest{
                Username: user.Username,
                Email:    user.Email,
                Password: user.Password,
        }
}</span>

func ProtoUserResponse(user *types.User) (*proto.UserResponse, error) <span class="cov8" title="1">{
        hashedPassword, err := bcrypt.GenerateFromPassword(
                []byte(user.Password),
                bcrypt.DefaultCost,
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">userProto := &amp;proto.UserResponse{
                Id:       "1234",
                Username: user.Username,
                Email:    user.Email,
                Password: string(hashedPassword),
        }
        return userProto, nil</span>
}

func ProtoUsernameRequest(user *types.User) *proto.UsernameRequest <span class="cov8" title="1">{
        return &amp;proto.UsernameRequest{
                Username: user.Username,
        }
}</span>

func Token() *types.Token <span class="cov8" title="1">{
        return &amp;types.Token{
                Value: "token",
        }
}</span>

func ProtoToken() *proto.Token <span class="cov8" title="1">{
        return &amp;proto.Token{
                Value: "token",
        }
}</span>

func UserToken() *types.UserToken <span class="cov8" title="1">{
        return &amp;types.UserToken{
                User:  *UserPublic(),
                Token: *Token(),
        }
}</span>
</pre>
		
		<pre class="file" id="file13" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: internal/services/token.go

// Package mocks is a generated GoMock package.
package mocks

import (
        reflect "reflect"
        time "time"

        types "github.com/Alieksieiev0/auth-service/internal/types"
        jwt "github.com/golang-jwt/jwt/v5"
        gomock "github.com/golang/mock/gomock"
)

// MockTokenService is a mock of TokenService interface.
type MockTokenService struct {
        ctrl     *gomock.Controller
        recorder *MockTokenServiceMockRecorder
}

// MockTokenServiceMockRecorder is the mock recorder for MockTokenService.
type MockTokenServiceMockRecorder struct {
        mock *MockTokenService
}

// NewMockTokenService creates a new mock instance.
func NewMockTokenService(ctrl *gomock.Controller) *MockTokenService <span class="cov8" title="1">{
        mock := &amp;MockTokenService{ctrl: ctrl}
        mock.recorder = &amp;MockTokenServiceMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockTokenService) EXPECT() *MockTokenServiceMockRecorder <span class="cov8" title="1">{
        return m.recorder
}</span>

// Create mocks base method.
func (m *MockTokenService) Create(user *types.User, expiresAfter time.Duration) (string, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Create", user, expiresAfter)
        ret0, _ := ret[0].(string)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// Create indicates an expected call of Create.
func (mr *MockTokenServiceMockRecorder) Create(user, expiresAfter interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Create", reflect.TypeOf((*MockTokenService)(nil).Create), user, expiresAfter)
}</span>

// Read mocks base method.
func (m *MockTokenService) Read(token string) (jwt.Claims, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Read", token)
        ret0, _ := ret[0].(jwt.Claims)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// Read indicates an expected call of Read.
func (mr *MockTokenServiceMockRecorder) Read(token interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Read", reflect.TypeOf((*MockTokenService)(nil).Read), token)
}</span>
</pre>
		
		<pre class="file" id="file14" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: api/proto/user_service_grpc.pb.go

// Package mock_proto is a generated GoMock package.
package mocks

import (
        context "context"
        reflect "reflect"

        proto "github.com/Alieksieiev0/auth-service/api/proto"
        gomock "github.com/golang/mock/gomock"
        grpc "google.golang.org/grpc"
)

// MockUserServiceClient is a mock of UserServiceClient interface.
type MockUserServiceClient struct {
        ctrl     *gomock.Controller
        recorder *MockUserServiceClientMockRecorder
}

// MockUserServiceClientMockRecorder is the mock recorder for MockUserServiceClient.
type MockUserServiceClientMockRecorder struct {
        mock *MockUserServiceClient
}

// NewMockUserServiceClient creates a new mock instance.
func NewMockUserServiceClient(ctrl *gomock.Controller) *MockUserServiceClient <span class="cov8" title="1">{
        mock := &amp;MockUserServiceClient{ctrl: ctrl}
        mock.recorder = &amp;MockUserServiceClientMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockUserServiceClient) EXPECT() *MockUserServiceClientMockRecorder <span class="cov8" title="1">{
        return m.recorder
}</span>

// GetByUsername mocks base method.
func (m *MockUserServiceClient) GetByUsername(ctx context.Context, in *proto.UsernameRequest, opts ...grpc.CallOption) (*proto.UserResponse, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        varargs := []interface{}{ctx, in}
        for _, a := range opts </span><span class="cov0" title="0">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov8" title="1">ret := m.ctrl.Call(m, "GetByUsername", varargs...)
        ret0, _ := ret[0].(*proto.UserResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1</span>
}

// GetByUsername indicates an expected call of GetByUsername.
func (mr *MockUserServiceClientMockRecorder) GetByUsername(ctx, in interface{}, opts ...interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        varargs := append([]interface{}{ctx, in}, opts...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetByUsername", reflect.TypeOf((*MockUserServiceClient)(nil).GetByUsername), varargs...)
}</span>

// Save mocks base method.
func (m *MockUserServiceClient) Save(ctx context.Context, in *proto.UserRequest, opts ...grpc.CallOption) (*proto.SaveResponse, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        varargs := []interface{}{ctx, in}
        for _, a := range opts </span><span class="cov0" title="0">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov8" title="1">ret := m.ctrl.Call(m, "Save", varargs...)
        ret0, _ := ret[0].(*proto.SaveResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1</span>
}

// Save indicates an expected call of Save.
func (mr *MockUserServiceClientMockRecorder) Save(ctx, in interface{}, opts ...interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        varargs := append([]interface{}{ctx, in}, opts...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Save", reflect.TypeOf((*MockUserServiceClient)(nil).Save), varargs...)
}</span>

// MockUserServiceServer is a mock of UserServiceServer interface.
type MockUserServiceServer struct {
        ctrl     *gomock.Controller
        recorder *MockUserServiceServerMockRecorder
}

// MockUserServiceServerMockRecorder is the mock recorder for MockUserServiceServer.
type MockUserServiceServerMockRecorder struct {
        mock *MockUserServiceServer
}

// NewMockUserServiceServer creates a new mock instance.
func NewMockUserServiceServer(ctrl *gomock.Controller) *MockUserServiceServer <span class="cov0" title="0">{
        mock := &amp;MockUserServiceServer{ctrl: ctrl}
        mock.recorder = &amp;MockUserServiceServerMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockUserServiceServer) EXPECT() *MockUserServiceServerMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// GetByUsername mocks base method.
func (m *MockUserServiceServer) GetByUsername(arg0 context.Context, arg1 *proto.UsernameRequest) (*proto.UserResponse, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetByUsername", arg0, arg1)
        ret0, _ := ret[0].(*proto.UserResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetByUsername indicates an expected call of GetByUsername.
func (mr *MockUserServiceServerMockRecorder) GetByUsername(arg0, arg1 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetByUsername", reflect.TypeOf((*MockUserServiceServer)(nil).GetByUsername), arg0, arg1)
}</span>

// Save mocks base method.
func (m *MockUserServiceServer) Save(arg0 context.Context, arg1 *proto.UserRequest) (*proto.SaveResponse, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Save", arg0, arg1)
        ret0, _ := ret[0].(*proto.SaveResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// Save indicates an expected call of Save.
func (mr *MockUserServiceServerMockRecorder) Save(arg0, arg1 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Save", reflect.TypeOf((*MockUserServiceServer)(nil).Save), arg0, arg1)
}</span>

// mustEmbedUnimplementedUserServiceServer mocks base method.
func (m *MockUserServiceServer) mustEmbedUnimplementedUserServiceServer() <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        m.ctrl.Call(m, "mustEmbedUnimplementedUserServiceServer")
}</span>

// mustEmbedUnimplementedUserServiceServer indicates an expected call of mustEmbedUnimplementedUserServiceServer.
func (mr *MockUserServiceServerMockRecorder) mustEmbedUnimplementedUserServiceServer() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "mustEmbedUnimplementedUserServiceServer", reflect.TypeOf((*MockUserServiceServer)(nil).mustEmbedUnimplementedUserServiceServer))
}</span>

// MockUnsafeUserServiceServer is a mock of UnsafeUserServiceServer interface.
type MockUnsafeUserServiceServer struct {
        ctrl     *gomock.Controller
        recorder *MockUnsafeUserServiceServerMockRecorder
}

// MockUnsafeUserServiceServerMockRecorder is the mock recorder for MockUnsafeUserServiceServer.
type MockUnsafeUserServiceServerMockRecorder struct {
        mock *MockUnsafeUserServiceServer
}

// NewMockUnsafeUserServiceServer creates a new mock instance.
func NewMockUnsafeUserServiceServer(ctrl *gomock.Controller) *MockUnsafeUserServiceServer <span class="cov0" title="0">{
        mock := &amp;MockUnsafeUserServiceServer{ctrl: ctrl}
        mock.recorder = &amp;MockUnsafeUserServiceServerMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockUnsafeUserServiceServer) EXPECT() *MockUnsafeUserServiceServerMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// mustEmbedUnimplementedUserServiceServer mocks base method.
func (m *MockUnsafeUserServiceServer) mustEmbedUnimplementedUserServiceServer() <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        m.ctrl.Call(m, "mustEmbedUnimplementedUserServiceServer")
}</span>

// mustEmbedUnimplementedUserServiceServer indicates an expected call of mustEmbedUnimplementedUserServiceServer.
func (mr *MockUnsafeUserServiceServerMockRecorder) mustEmbedUnimplementedUserServiceServer() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "mustEmbedUnimplementedUserServiceServer", reflect.TypeOf((*MockUnsafeUserServiceServer)(nil).mustEmbedUnimplementedUserServiceServer))
}</span>
</pre>
		
		<pre class="file" id="file15" style="display: none">package utils

import (
        "time"

        "github.com/Alieksieiev0/auth-service/tests/data"
        "github.com/Alieksieiev0/auth-service/tests/mocks"
        "github.com/golang/mock/gomock"
)

const Exp time.Duration = time.Hour * 6

func ExpectGetByUsername(m *mocks.MockUserServiceClient) error <span class="cov8" title="1">{
        user := data.User()
        username := data.ProtoUsernameRequest(user)
        userProto, err := data.ProtoUserResponse(user)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">m.EXPECT().
                GetByUsername(gomock.Any(), gomock.Eq(username)).
                Return(userProto, nil)
        return nil</span>
}

func ExpectSave(m *mocks.MockUserServiceClient) <span class="cov8" title="1">{
        userProto := data.ProtoUserRequest(data.User())
        m.EXPECT().Save(gomock.Any(), gomock.Eq(userProto)).Return(nil, nil)
}</span>

func ExpectCreate(m *mocks.MockTokenService) <span class="cov8" title="1">{
        userPublic := data.UserPublic()
        token := data.Token()

        m.EXPECT().Create(gomock.Eq(userPublic), gomock.Eq(Exp)).Return(token.Value, nil)
}</span>

func ExpectRead(m *mocks.MockTokenService) <span class="cov8" title="1">{
        token := data.Token()
        claims := data.UserClaims()
        m.EXPECT().Read(gomock.Eq(token.Value)).Return(claims, nil)
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
